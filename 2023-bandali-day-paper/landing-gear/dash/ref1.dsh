/* The Landing Gear case study - Dash model

Copyright (c) 2020 Amin Bandali <bandali@uwaterloo.ca>
Copyright (c) 2020 Nancy Day <nday@uwaterloo.ca>

This file is part of the Landing Gear Dash model.

The Landing Gear Dash model is free software: you can redistribute it
and/or modify it under the terms of the GNU General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

The Landing Gear Dash model is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with the Landing Gear Dash model.  If not, see
<https://www.gnu.org/licenses/>.


The Landing Gear management case study is described in
\cite{DBLP:conf/asm/BoniolW14} by Boniol et al.

@inproceedings{DBLP:conf/asm/BoniolW14,
  author    = {Fr{\'{e}}d{\'{e}}ric Boniol and
               Virginie Wiels},
  editor    = {Fr{\'{e}}d{\'{e}}ric Boniol and
               Virginie Wiels and
               Yamine A{\"{\i}}t Ameur and
               Klaus{-}Dieter Schewe},
  title     = {The Landing Gear System Case Study},
  booktitle = {{ABZ} 2014: The Landing Gear Case Study - Case Study Track, Held at
               the 4th International Conference on Abstract State Machines, Alloy,
               B, TLA, VDM, and Z, Toulouse, France, June 2-6, 2014. Proceedings},
  series    = {Communications in Computer and Information Science},
  volume    = {433},
  pages     = {1--18},
  publisher = {Springer},
  year      = {2014},
  url       = {https://doi.org/10.1007/978-3-319-07512-9\_1},
  doi       = {10.1007/978-3-319-07512-9\_1},
  timestamp = {Tue, 07 May 2019 12:19:36 +0200},
  biburl    = {https://dblp.org/rec/conf/asm/BoniolW14.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

The Landing Gear Dash model is an adaptation of the AsmetaL one
described in \cite{DBLP:conf/asm/ArcainiGR14} by Arcaini et al.

@inproceedings{DBLP:conf/asm/ArcainiGR14,
  author    = {Paolo Arcaini and
               Angelo Gargantini and
               Elvinia Riccobene},
  editor    = {Fr{\'{e}}d{\'{e}}ric Boniol and
               Virginie Wiels and
               Yamine A{\"{\i}}t Ameur and
               Klaus{-}Dieter Schewe},
  title     = {Modeling and Analyzing Using ASMs: The Landing Gear System Case Study},
  booktitle = {{ABZ} 2014: The Landing Gear Case Study - Case Study Track, Held at
               the 4th International Conference on Abstract State Machines, Alloy,
               B, TLA, VDM, and Z, Toulouse, France, June 2-6, 2014. Proceedings},
  series    = {Communications in Computer and Information Science},
  volume    = {433},
  pages     = {36--51},
  publisher = {Springer},
  year      = {2014},
  url       = {https://doi.org/10.1007/978-3-319-07512-9\_3},
  doi       = {10.1007/978-3-319-07512-9\_3},
  timestamp = {Wed, 29 May 2019 09:35:57 +0200},
  biburl    = {https://dblp.org/rec/conf/asm/ArcainiGR14.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

This model has appeared in the following publications:

TODO

*/


open util/boolean

enum HandleStatus {UP, DOWN}
enum DoorStatus {CLOSED, OPENING, OPEN, CLOSING}
enum GearStatus {RETRACTED, EXTENDING, EXTENDED, RETRACTING}
enum CylinderStatus {CYLINDER_RETRACTED, CYLINDER_EXTENDING,
                     CYLINDER_EXTENDED, CYLINDER_RETRACTING}

fun cylinders_doors[d: DoorStatus]: CylinderStatus {
    d = OPEN implies CYLINDER_EXTENDED
    else d = OPENING implies CYLINDER_EXTENDING
    else d = CLOSING implies CYLINDER_RETRACTING
    else d = CLOSED implies CYLINDER_RETRACTED
    else CYLINDER_RETRACTED // should never be reached
}

fun cylinders_gears[g: GearStatus]: CylinderStatus {
    g = RETRACTED implies CYLINDER_RETRACTED
    else g = EXTENDING implies CYLINDER_EXTENDING
    else g = EXTENDED implies CYLINDER_EXTENDED
    else g = RETRACTING implies CYLINDER_RETRACTING
    else CYLINDER_RETRACTED // should never be reached
}

pred close_door[d1, d2: DoorStatus,
                gev1, gev2, cdev1, cdev2, odev1, odev2: Bool] {
    d1 = OPEN implies {
        d2 = CLOSING
        and gev2 = gev1
        and cdev2 = True
        and odev2 = odev1
    }
    else d1 = CLOSING implies {
        d2 = CLOSED
        and gev2 = False
        and cdev2 = False
        and odev2 = odev1
    }
    else d1 = OPENING implies {
        d2 = CLOSING
        and gev2 = gev1
        and cdev2 = True
        and odev2 = False
    }
}

state LandingGear {
    env handle: one HandleStatus
    doors: one DoorStatus
    gears: one GearStatus

    general_electro_valve: one Bool
    open_doors_electro_valve: one Bool
    close_doors_electro_valve: one Bool
    retract_gears_electro_valve: one Bool
    extend_gears_electro_valve: one Bool

    trans retraction_sequence {
        when handle = UP
        do {
            gears != RETRACTED implies {
                doors = CLOSED implies {
                    doors' = OPENING
                    and general_electro_valve' = True
                    and open_doors_electro_valve' = True
                }
                else doors = CLOSING implies {
                    doors' = OPENING
                    and close_doors_electro_valve' = False
                    and open_doors_electro_valve' = True
                }
                else doors = OPENING implies {
                    doors' = OPEN
                    open_doors_electro_valve' = False
                }
                else doors = OPEN implies {
                    gears = EXTENDED implies {
                        gears' = RETRACTING
                        and retract_gears_electro_valve' = True
                    }
                    else gears = RETRACTING implies {
                        gears' = RETRACTED
                        and retract_gears_electro_valve' = False
                    }
                    else gears = EXTENDING implies {
                        gears' = RETRACTING
                        and extend_gears_electro_valve' = False
                        and retract_gears_electro_valve' = True
                    }
                }
            }
            else close_door[doors, doors',
                            general_electro_valve,
                            general_electro_valve',
                            close_doors_electro_valve,
                            close_doors_electro_valve',
                            open_doors_electro_valve,
                            open_doors_electro_valve']
        }
    }

    trans outgoing_sequence {
        when handle != UP
        do {
            gears != EXTENDED implies {
                doors = CLOSED implies {
                    doors' = OPENING
                    and general_electro_valve' = True
                    and open_doors_electro_valve' = True
                }
                else doors = OPENING implies {
                    doors' = OPEN
                    and open_doors_electro_valve' = False
                }
                else doors = OPEN implies {
                    gears = RETRACTED implies {
                        gears' = EXTENDING
                        and extend_gears_electro_valve' = True
                    }
                    else gears = EXTENDING implies {
                        gears' = EXTENDED
                        and extend_gears_electro_valve' = False
                    }
                    else gears = RETRACTING implies {
                        gears' = EXTENDING
                        and extend_gears_electro_valve' = True
                        and retract_gears_electro_valve' = False
                    }
                }
            }
            else close_door[doors, doors',
                            general_electro_valve,
                            general_electro_valve',
                            close_doors_electro_valve,
                            close_doors_electro_valve',
                            open_doors_electro_valve,
                            open_doors_electro_valve']
        }
    }

    invariant {
        (gears = EXTENDING or gears = RETRACTING) implies doors = OPEN
    }

    invariant {
        doors = CLOSED implies (gears = EXTENDED or gears = RETRACTED)
    }

    init {
        doors = CLOSED
        gears = EXTENDED
        general_electro_valve = False
        open_doors_electro_valve = False
        close_doors_electro_valve = False
        retract_gears_electro_valve = False
        extend_gears_electro_valve = False
    }
}


assert R11_bis {
    ag(ag(LandingGear/handle = DOWN) implies
        af(LandingGear/gears = EXTENDED and LandingGear/doors = CLOSED))
}

assert R12_bis {
    ag(ag(LandingGear/handle = UP) implies
        af(LandingGear/gears = RETRACTED and LandingGear/doors = CLOSED))
}

assert R21 {
    ag(ag(LandingGear/handle = DOWN) implies
        ax(ag(LandingGear/gears != RETRACTING)))
}

assert R22 {
    ag(ag(LandingGear/handle = UP) implies
        ax(ag(LandingGear/gears != EXTENDING)))
}

assert R31 {
    ag((LandingGear/extend_gears_electro_valve = True
        or LandingGear/retract_gears_electro_valve = True)
            implies LandingGear/doors = OPEN)
}

assert R32 {
    ag((LandingGear/open_doors_electro_valve = True
        or LandingGear/close_doors_electro_valve = True)
            implies (LandingGear/gears = RETRACTED
                     or LandingGear/gears = EXTENDED))
}

assert R41 {
    ag(not(LandingGear/open_doors_electro_valve = True
           and LandingGear/close_doors_electro_valve = True))
}

assert R42 {
    ag(not(LandingGear/extend_gears_electro_valve = True
           and LandingGear/retract_gears_electro_valve = True))
}

assert R51 {
    ag((LandingGear/open_doors_electro_valve = True
        or LandingGear/close_doors_electro_valve = True
        or LandingGear/extend_gears_electro_valve = True
        or LandingGear/retract_gears_electro_valve = True)
       implies LandingGear/general_electro_valve = True)
}

